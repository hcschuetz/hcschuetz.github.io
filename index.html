<!DOCTYPE html>
<html>
<head>
  <title>Code and Demos by Heribert Schütz</title>
  <!-- <meta name='viewport' content='width=device-width, initial-scale=1'> -->
  <style>
    /*
    According to caniuse.com there are still too many browsers in use
    without CSS-nesting support.  So I unnested.
     */
    body {
      font-family: Arial, Helvetica, sans-serif;
      max-width: 700px;
      margin: 0 auto;
      padding: 2rem;
      background-color: #002;
      color: #ffc;
    }
    h1 {
      font-size: 200%;
      margin-bottom: 0;
    }
    h2 {
      font-size: 120%;
      margin-top: 4ex;
      /* text-decoration: underline; */
    }
    h1 {
      counter-reset: h2counter;
    }
    h2:before {
      content: counter(h2counter) ". ";
      counter-increment: h2counter;
    }
    a {
      color: #aaf;
    }
    a:hover {
      color: #ccf;
    }
    a:visited {
      color: #aa8;
    }
    a:visited:hover {
      color: #cca;
    }
    code {
      font-size: 120%;
    }
  </style>
</head>
<body>
  <h1>Code and Demos</h1>
  <p style="
    font-size: 120%;
    font-style: italic;
    margin: 0.5rem 0 2rem;
  ">Heribert Schütz</p>

  <p>
    Like many others I have implemented various experimental projects to
    investigate technologies or just for fun.
    This site contains a small selection of projects that might
    also be of interest for others.
  </p>

  <h2>The Scaling Factor in the Gaussian Distribution</h2>

  <a href="gaussian-scaling/dist/">Demo</a>,
  <a href="https://github.com/hcschuetz/gaussian-scaling">Source</a>

  <p>
    This project had two goals:
  </p>
  <ol>
    <li>
      <p>
        Explaining the scaling factor 1/sqrt(2π) in the formula for the
        Gaussian distribution (also called "normal" distribution).
      </p>
    </li>
    <li>
      <p>
        Experimenting with various web technologies, in particular
      </p>
      <ul>
        <li>
          <p>
            three.js and related tools for (dynamic) 3D graphics and
          </p>
        </li>
        <li>
          <p>
            rendering (dynamic) TeX formulas in HTML
          </p>
        </li>
      </ul>
      <p>
        to see whether something like Manim
        (see <a href="https://github.com/3b1b/manim">here</a>
        and <a href="https://github.com/ManimCommunity/manim">here</a>)
        could also be built on top of web technologies.
      </p>
    </li>
  </ol>
  <p>
    Goal #1 actually became obsolete when 3Blue1Brown published
    <a href="https://www.youtube.com/watch?v=cy8r7WSuT1I">his video series</a>
    on that same topic when I was about to get my presentation completed.
  </p>
  <p>
    But I think goal #2 was achieved.
    While my web-based tools still have limited functionality
    and would benefit from some polishing,
    I see no major obstacles against getting on a par with Manim.
  </p>
  <p>
    The web-based approach has its own advantages:
  </p>
  <ul>
    <li>Live interaction with the slides is possible.</li>
    <li>Slides can be published easily for the audience to play with.</li>
  </ul>

  <h2>Graphics Sketchbook</h2>

  <a href="graphics-sketchbook/dist/">Demo</a>,
  <a href="https://github.com/hcschuetz/graphics-sketchbook">Source</a>

  <p>
    Some experiments with three.js and react-three-fiber.
  </p>
  <p>
    Features the Stanford Bunny, the Utah Teapot, and demos ported from Manim.
  </p>

  <h2>Performance study based on the Fast Fourier Transformation (FFT)</h2>

  <a href="fft/build/">Demo</a>,
  <a href="https://github.com/hcschuetz/fft">Source</a>

  <p>
    With this project I investigated high-performance-computing capabilities
    of the Web platform.
    The Fast Fourier Transformation was chosen as a number-crunching example
    with non-trivial complexity,
    but which is still simple enough to implement various versions.
  </p>
  <p>
    The FFT implementations vary in several aspects:
  </p>
  <ul>
    <li>home-grown and third-party implementations</li>
    <li>from very naive to quite refined algorithms</li>
    <li>programming languages:
      TypeScript, C++, Rust, and even a small home-grown language
    </li>
    <li>runtime technologies:
      JavaScript, Web Assembly (WASM),
      native code (for comparison, not in the browser demo)
    </li>
  </ul>
  <p>
    The performance tests can take quite a while.
    Therefore they run in a Web Worker, avoiding a frozen UI
    and allowing to interrupt the tests.
  </p>
  <p>
    The FFT demo includes two application demos, which are more entertaining:
  </p>
  <ul>
    <li>
      <a href="fft/build/#ClockworkDemo">One demo</a>
      uses FFT to create moving graphical output
      (using SVG or the <code>Canvas</code> API)
    </li>
    <li>
      <a href="fft/build#AudioDemo">The other demo</a>
      uses FFT to analyze sound input captured with the Web Audio API.
    </li>
  </ul>
  
  <h2>Guitar Simulation</h2>
  
  <a href="guitar-simulation/">Demo</a>,
  <a href="https://github.com/hcschuetz/guitar-simulation">Source</a>

  <p>
    While the audio demo in the FFT project analyzes <em>incoming audio</em>,
    this project uses the Web Audio API to synthesize <em>outgoing audio</em>.
  </p>

  <h2>TodoMVC with MobX, Custom Elements and JSX</h2>

  <a href="todomvc-mobx-jsx/dist/">Demo</a>,
  <a href="https://github.com/hcschuetz/todomvc-mobx-jsx">Source</a>

  <p>
    (The demo is just a clone of the standard TodoMVC demo.
    But inspecting the DOM may be interesting.)
  </p>

  <p>
    In this project I have explored an approach for building web applications
    based on a reactive state
    (provided by <em>MobX</em> and <em><code>mobx-keystone</code></em>).
    The idea was that the reactive state can be mapped to a UI dynamically
    so that a powerful framework such as React is no more needed.
  </p>
  <p>
    I do, however, use a light-weight home-grown <em>JSX</em> implementation,
    which makes the application code succinct and readable.
  </p>
  <p>
    <em>Custom elements</em>
    (one of the technologies for Web Components, supported directly by browsers)
    help to structure the application.
  </p>
  <p>
    The experiment was actually quite successful.
    The approach should be suitable for projects that require
    (or benefit from) reactive state management anyway.
    A typical example for this would be the configuration of complex products.
  </p>

  <h2>15 Puzzle</h2>

  <a href="15-puzzle/dist/">Demo</a>,
  <a href="https://github.com/hcschuetz/15-puzzle">Source</a>

  <p>
    An experimental/demo app from 2015 using React and Redux.
  </p>
  <p>
    I have modernized the dev/build tools from webpack to vite.
    Maybe I should also modernize the actual implementation and libs.
  </p>
</body>
</html>
